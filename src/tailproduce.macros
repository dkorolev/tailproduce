// TailProduce static framework macros.
// Static framework is the one that lists all the streams in the source file,
// thus allowing all C++ template and static typing powers to come into play.
#define TAILPRODUCE_STATIC_FRAMEWORK_BEGIN(NAME, BASE) \
    class NAME { \
      public: \
        typedef NAME framework_type; \
        typedef typename BASE::storage_type storage_type; \
        storage_type& storage; \
        static storage_type& EnsureStreamsAreCreatedDuringInitialization( \
                storage_type& storage, \
                const ::TailProduce::StreamManagerParams& params) { \
            params.Apply(storage); \
            return storage; \
        } \
        NAME(storage_type& storage, \
             const ::TailProduce::StreamManagerParams& params = ::TailProduce::StreamManagerParams::FromCommandLineFlags()) \
          : storage(EnsureStreamsAreCreatedDuringInitialization(storage, params)) { \
            ::TailProduce::EnsureThereAreNoStreamsWithoutPublishers(streams_declared_, stream_publishers_declared_); \
        } \
        NAME(const NAME&) = delete; \
        NAME(NAME&&) = delete; \
        void operator=(const NAME&) = delete; \
      private: \
        using TSM = ::TailProduce::StreamManager; \
        static_assert(std::is_base_of<TSM, BASE>::value, \
                      "TAILPRODUCE_STATIC_FRAMEWORK_BEGIN: BASE should be derived from StreamManager."); \
        using TS = ::TailProduce::Storage; \
        static_assert(std::is_base_of<TS, storage_type>::value, \
                      "TAILPRODUCE_STATIC_FRAMEWORK_BEGIN: BASE::storage_type should be derived from Storage."); \
        ::TailProduce::StreamsRegistry registry_;  \
        std::set<std::string> streams_declared_; \
        std::set<std::string> stream_publishers_declared_; \
      public: \
        typedef BASE captured_base; \
        const ::TailProduce::StreamsRegistry& registry() const { return registry_; }

#define TAILPRODUCE_STREAM(NAME, ENTRY_TYPE, ORDER_KEY_TYPE) \
        struct NAME##_type { \
            typedef ENTRY_TYPE entry_type; \
            typedef ORDER_KEY_TYPE order_key_type; \
            typedef ::TailProduce::StreamInstance<entry_type, order_key_type> stream_type; \
            typedef typename captured_base::storage_type storage_type; \
            typedef ::TailProduce::INTERNAL_UnsafeListener<NAME##_type> INTERNAL_unsafe_listener_type; \
            typedef ::TailProduce::INTERNAL_UnsafePublisher<NAME##_type> INTERNAL_unsafe_publisher_type; \
            typedef ::TailProduce::Publisher<NAME##_type> publisher_type; \
            typedef std::pair<order_key_type, uint32_t> head_pair_type; \
            typedef ::TailProduce::StorageKeyBuilder<NAME##_type> key_builder_type; \
            framework_type* manager; \
            stream_type stream; \
            const std::string name; \
            key_builder_type key_builder; \
            head_pair_type head; \
            ::TailProduce::ConfigValues cv = ::TailProduce::ConfigValues("S", "D", "Register", "LastWrite", ':'); \
            mutable ::TailProduce::SubscriptionsManager subscriptions; \
            NAME##_type( \
                framework_type* manager, \
                const char* stream_name, \
                const char* entry_type_name, \
                const char* entry_order_key_name) \
              : manager(manager), \
                stream(manager->registry_, cv, stream_name, entry_type_name, entry_order_key_name), \
                name(stream_name), \
                key_builder(name), \
                head(::TailProduce::StreamManager::template FetchHeadOrDie<order_key_type, key_builder_type, storage_type>(name, key_builder, manager->storage)) { \
                manager->streams_declared_.insert(#NAME); \
            } \
        }; \
        NAME##_type NAME = NAME##_type(this, #NAME, #ENTRY_TYPE, #ORDER_KEY_TYPE); \
        ::TailProduce::AsyncListenersFactory<NAME##_type> new_scoped_##NAME##_listener = ::TailProduce::AsyncListenersFactory<NAME##_type>(NAME)

#define TAILPRODUCE_PUBLISHER(NAME) \
        struct NAME##_publisher_type : ::TailProduce::Publisher<NAME##_type> { \
            typedef ::TailProduce::Publisher<NAME##_type> base; \
            explicit NAME##_publisher_type(framework_type* manager) : base(manager->NAME) { \
                manager->stream_publishers_declared_.insert(#NAME); \
            } \
        }; \
        NAME##_publisher_type NAME##_publisher = NAME##_publisher_type(this);

#define TAILPRODUCE_STATIC_FRAMEWORK_END() \
    }
